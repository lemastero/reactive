## Elements

### `RElem`

Often you can use events and properties on their own, since they are
`NodeSeq=>NodeSeq` or `Elem=>Elem` functions.
There also exists the trait `RElem`, which you can use directly
or via classes and traits that extend it.
`RElem` contains a base `scala.xml.Elem`, a
unique id, a set of `DomEventSource`s and `DomProperty`s,
and a set of `Page`s it has been rendered to. When you call `render`
on an `RElem`, which returns an `Elem`, it finds the current `Page` via the
implicits scope (if you don’t pass one in explicitly), records it, and
adds it to all `DomProperty`s. Then, a `scala.xml.Elem`
is returned, which is generated by starting with `baseElem`,
adding the id attribute, adding attributes that correspond to the
current values of the properties, and adding event handler attributes
for those `DomEventSource`s to which listeners have been
added.

There are a number of ways to get `RElem` instances.
Of course, you can subclass it yourself. There are also many traits, classes,
and factories for HTML elements, such as form elements. There’s a
general-purpose factory, `RElem.apply(parentElem:
scala.xml.Elem, children: RElem*)`, which wraps a regular `scala.xml.Elem`
(and optionally some `RElems` to put inside), and its
overload, `RElem.apply(text: String)`, which returns an `RElem`
that wraps a `<span>` containing the text. And there’s `Cell`
and `Repeater`.

### <a name="Cell">`Cell`</a>

If you want the contents of an element to be dynamic, you
may want to use `Cell`. `Cell` is a trait that extends `RElem`. It
is used to manage an `RElem` whose contents — its child
elements — are represented by a `Signal[NodeSeq]`. It
is available through implementations that extend it. But it also has a
factory that can be used in CSS selector binding, to make the contents
of any element — even one defined in a template — dynamic.

This factory actually takes and returns a `NodeSeq=>NodeSeq`.
When the returned function is called, it instantiates an `RElem`,
using the (template) `NodeSeq` passed to it as the outer
element. Its children are generated by running the binding function
passed in on the children of the template element.

 <div data-lift="DemoPane?snippet=CellDemo"></div>

### <a name="Repeater"></a>`Repeater`

`Repeater` is the `SeqSignal` counterpart
of `Cell`. Where `Cell` defines its entire
contents using a `Signal` — whenever the `Signal`’s
value changes, the entire contents of the element have to be replaced
— `Repeater` uses a `SeqSignal[NodeSeq]`.
This is a very powerful feature. It means you can represent a dynamic
set of items, completely declaratively, and (without you worrying about
the details) when items change, only what needs updating will be
updated.

Besides for implementations such as `Select` (for HTML
select elements), `Repeater` has a factory similar to `Cell`’s.

Once again, you pass the factory a binding function to be run on
the children of the template element, and it returns a binding function
that lift runs against the template. When run, the function instantiates
an `RElem` that uses the element from the template as the
outer element, and the binding function you passed to the factory is run
on each element.

 <div data-lift="DemoPane?snippet=RepeaterDemo"></div>
